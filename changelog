diff --git a/pkg/scheduler/actions/common/action.go b/pkg/scheduler/actions/common/action.go
index 0162983..b7958e9 100644
--- a/pkg/scheduler/actions/common/action.go
+++ b/pkg/scheduler/actions/common/action.go
@@ -5,7 +5,7 @@ package common
 
 import (
 	"fmt"
-
+	"k8s.io/klog/v2"
 	"k8s.io/apimachinery/pkg/types"
 
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/actions/utils"
@@ -17,14 +17,33 @@ import (
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/framework"
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/log"
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/scheduler_util"
+	scheduler_util "github.com/NVIDIA/KAI-scheduler/pkg/scheduler/scheduler_util"
 )
 
 func EvictAllPreemptees(ssn *framework.Session, preempteeTasks []*pod_info.PodInfo,
 	preemptor *podgroup_info.PodGroupInfo, stmt *framework.Statement,
 	actionType framework.ActionType) error {
 
-	messages := getEvictionMessages(ssn, preempteeTasks, preemptor, actionType)
-	for _, task := range preempteeTasks {
+    // -------- Safety net #3: never evict non-preemptible pods --------
+    evictable := make([]*pod_info.PodInfo, 0, len(preempteeTasks))
+    for _, t := range preempteeTasks {
+        if t == nil || t.Pod == nil {
+            continue
+        }
+        if scheduler_util.IsNonPreemptible(t.Pod) {
+            klog.V(3).InfoS("Refusing to evict non-preemptible pod",
+                "pod", klog.KObj(t.Pod), "node", t.NodeName, "action", actionType)
+            continue
+        }
+        evictable = append(evictable, t)
+    }
+    // If nothing is left to evict, just return nil (scenario will naturally fail later if it cannot fit).
+    if len(evictable) == 0 {
+        return nil
+    }
+
+	messages := getEvictionMessages(ssn, evictable, preemptor, actionType)
+	for _, task := range evictable {
 		message, found := messages[task.UID]
 		if !found {
 			return fmt.Errorf("failed to find message for task: %s", task.UID)
@@ -33,7 +52,7 @@ func EvictAllPreemptees(ssn *framework.Session, preempteeTasks []*pod_info.PodIn
 			task.Namespace, task.Name, message)
 		err := stmt.Evict(task, message, eviction_info.EvictionMetadata{
 			Action:           string(actionType),
-			EvictionGangSize: len(preempteeTasks),
+			EvictionGangSize: len(evictable),
 			Preemptor:        &types.NamespacedName{Namespace: preemptor.Namespace, Name: preemptor.Name},
 		})
 		if err != nil {
diff --git a/pkg/scheduler/actions/common/solvers/pod_scenario_builder.go b/pkg/scheduler/actions/common/solvers/pod_scenario_builder.go
index 688e61b..5b99fa6 100644
--- a/pkg/scheduler/actions/common/solvers/pod_scenario_builder.go
+++ b/pkg/scheduler/actions/common/solvers/pod_scenario_builder.go
@@ -5,6 +5,7 @@ package solvers
 
 import (
 	"golang.org/x/exp/slices"
+	"k8s.io/klog/v2"
 
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/actions/common/solvers/accumulated_scenario_filters"
 	solverscenario "github.com/NVIDIA/KAI-scheduler/pkg/scheduler/actions/common/solvers/scenario"
@@ -15,6 +16,7 @@ import (
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/framework"
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/log"
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/metrics"
+	scheduler_util "github.com/NVIDIA/KAI-scheduler/pkg/scheduler/scheduler_util"
 )
 
 type PodAccumulatedScenarioBuilder struct {
@@ -79,6 +81,13 @@ func (asb *PodAccumulatedScenarioBuilder) addNextPotentialVictims() bool {
 		nextVictimJob, asb.session.SubGroupOrderFn, asb.session.TaskOrderFn,
 	)
 
+	// --- Non-preemptible guard (pod-level) ---
+	potentialVictimTasks = filterNonPreemptibleTasks(potentialVictimTasks)
+	if len(potentialVictimTasks) == 0 && !jobHasMoreTasks {
+		// Nothing usable from this job right now.
+		return true
+	}
+
 	// Jump over recorded victims in potential victims generation
 	for _, potentialVictimTask := range potentialVictimTasks {
 		if _, ok := asb.recordedVictimsTasks[potentialVictimTask.UID]; ok {
@@ -117,6 +126,26 @@ func (asb *PodAccumulatedScenarioBuilder) addNextPotentialVictims() bool {
 	return true
 }
 
+// Keep only pods that are allowed to be evicted.
+func filterNonPreemptibleTasks(tasks []*pod_info.PodInfo) []*pod_info.PodInfo {
+       if len(tasks) == 0 {
+               return tasks
+       }
+       kept := tasks[:0]
+       for _, t := range tasks {
+               if t == nil || t.Pod == nil {
+                       continue
+               }
+               if scheduler_util.IsNonPreemptible(t.Pod) {
+                       klog.V(4).InfoS("Skipping non-preemptible pod as potential victim",
+                               "pod", klog.KObj(t.Pod), "node", t.NodeName)
+                       continue
+               }
+               kept = append(kept, t)
+       }
+       return kept
+}
+
 func (asb *PodAccumulatedScenarioBuilder) GetValidScenario() *solverscenario.ByNodeScenario {
 	if isValid, failedFilterName := asb.isScenarioValid(); !isValid {
 		log.InfraLogger.V(5).Infof("Filtered by %s for scenario: %s", failedFilterName, asb.lastScenario)
diff --git a/pkg/scheduler/actions/preempt/preempt.go b/pkg/scheduler/actions/preempt/preempt.go
index dfa7122..95730b7 100644
--- a/pkg/scheduler/actions/preempt/preempt.go
+++ b/pkg/scheduler/actions/preempt/preempt.go
@@ -30,6 +30,7 @@ import (
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/framework"
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/log"
 	"github.com/NVIDIA/KAI-scheduler/pkg/scheduler/metrics"
+	scheduler_util "github.com/NVIDIA/KAI-scheduler/pkg/scheduler/scheduler_util"
 )
 
 type preemptAction struct {
@@ -144,6 +145,23 @@ func buildFilterFuncForPreempt(ssn *framework.Session, preemptor *podgroup_info.
 			return false
 		}
 
+        // Only consider tasks that are *actually evictable* by the solver:
+        potentialVictimTasks, _ := podgroup_info.GetTasksToEvict(
+            job, ssn.SubGroupOrderFn, ssn.TaskOrderFn,
+        )
+		// If all potential victims are protected, skip this job entirely.
+        hasPreemptibleVictim := false
+        for _, t := range potentialVictimTasks {
+            if t != nil && t.Pod != nil && !scheduler_util.IsNonPreemptible(t.Pod) {
+                hasPreemptibleVictim = true
+                break
+            }
+        }
+
+        if !hasPreemptibleTasks {
+            return false
+        }
+
 		if !ssn.PreemptVictimFilter(preemptor, job) {
 			return false
 		}
diff --git a/pkg/scheduler/scheduler_util/non_preemptible.go b/pkg/scheduler/scheduler_util/non_preemptible.go
new file mode 100644
index 0000000..51e8a0e
--- /dev/null
+++ b/pkg/scheduler/scheduler_util/non_preemptible.go
@@ -0,0 +1,24 @@
+package scheduler_util
+
+import (
+	"strings"
+
+	v1 "k8s.io/api/core/v1"
+)
+
+const NonPreemptibleKey = "scheduler.kai/non-preemptible"
+
+func IsNonPreemptible(pod *v1.Pod) bool {
+	// Prefer label, but also support annotation with the same key.
+	val, ok := pod.Labels[NonPreemptibleKey]
+	if !ok {
+		val = pod.Annotations[NonPreemptibleKey]
+	}
+
+	switch strings.ToLower(strings.TrimSpace(val)) {
+	case "true", "1", "yes", "y":
+		return true
+	default:
+		return false
+	}
+}
